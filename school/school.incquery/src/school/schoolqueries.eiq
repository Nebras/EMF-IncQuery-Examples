package school

import "http://school.ecore"

 
 /*
 * Step 1: simple queries
 */
 
 // all schools
 pattern schools(Sch) = {
 	School(Sch);
 }
 
 // all students
 pattern teachers(T) = {
 	Teacher(T);
 }
 
 // query along a reference
 pattern teachersOfSchool(T:Teacher,Sch:School) = {
 	School.teachers(Sch,T); 
 	// note that there is no restriction on the direction of navigation:
 	// all "Sch"s can be queried from Ts and vice-versa
 }
 
 
 /*
  * Step 2: pattern calls, negative application conditions
  */
 pattern coursesOfTeacher(T:Teacher, C:Course) = {
 	Teacher.courses(T,C);
 } 

 pattern classesOfTeacher(T:Teacher, SC:SchoolClass) = {
 	find coursesOfTeacher(T,C);
 	Course.schoolClass(C,SC);
 	// could also be shorter: Teacher.courses.schoolClass(T,SC);
 }
 
 pattern teacherWithoutClass(T:Teacher) = {
	neg find classesOfTeacher(T,SC); 	
 }

 /*
  * Step 3: path expressions
  */
 pattern studentOfSchool(S:Student,Sch:School) = {
 	Student.schoolClass.courses.school(S,Sch);
 	// logically equivalent: School.courses.schoolClass.students(Sch,S);
 }
  
 /*
  * Step 4: check conditions
  */
  
 // attribute value constraint with a constant
 pattern courseWithWeightThirty(C:Course) = {
 	Course.weight(C,30);
 }
 
 // a bit more complicated check expression
 pattern courseWithNameLongerThanWeight(C:Course) = {
 	Course.subject(C,CName);
 	Course.weight(C,W);
 	check((CName as String).length > (W as Integer));
 	// casts will not be necessary once IncQuery has full type inference (v.0.7)
 }
 
  // check condition with some XBase magic
 // this must be the most primitive prime tester ever
 pattern courseWithPrimeWeight(C:Course) = {
 	Course.weight(C,W);
 	check({ // make sure the check() expression returns a boolean value on all execution paths
 		var Integer weight = (W as Integer) 
 		if (weight%2==0) return false
 		var Integer maxValue = Math::round(new Float(Math::sqrt( weight )))
 		var Integer divisor = 3
 		while (divisor<=maxValue) {
 			if (weight%divisor==0) return false // we have found a divisor
 			else divisor = divisor + 2;
 			}
 		return true // we have found a prime number	
 		}
 	);
 }
 
 // for the limitations on check() expressions, see https://viatra.inf.mit.bme.hu/incquery/language#Limitations
 // for details on Xbase expressions, see http://www.eclipse.org/Xtext/documentation/2_1_0/199h-xbase-language-reference-expressions.php
 
 /*
  * Step 5: counting, simple check condition, negative application condition
  */
  // T1 teaches more classes than T2
  @Off // this @Off annotation hides this pattern from the UI
  pattern teachesMoreClasses(T1:Teacher, T2:Teacher) = {
  	N == count find classesOfTeacher(T1,_SC1);
  	M == count find classesOfTeacher(T2,_SC2);
  	check((N as Integer) > (M as Integer));
  }
  
  pattern teachesTheMostCourses(T:Teacher) = {
  	neg find teachesMoreClasses(_Tx,T);
  }
  
  /*
   * Step 6: disjunction, recursion, transitive closure
   */
   // S1 is friendly to S2, i.e. they are friends in either direction
   @Off
   pattern friendlyTo(S1:Student, S2:Student) = {
   	Student.friendsWith(S1,S2);
   } or {
   	Student.friendsWith(S2,S1);
   }
   
   pattern inTheCircleOfFriends(S1:Student, Someone:Student) = {
   	find friendlyTo(S1,Someone);
   	S1!=Someone;
   } or {
   	find friendlyTo(S1,CommonFriend);
   	find inTheCircleOfFriends(CommonFriend,Someone);
   	S1!=Someone;
   }
   
   pattern inTheCircleOfFriends_shorter(S1:Student,Someone:Student) = {
   	find friendlyTo+(S1,Someone);
   	// this is not only a short-hand notation, but also much more efficient!
   	// use it whenever possible
   }
   
   @Off
   pattern moreFriendsThan(S1:Student,S2:Student) = {
   	N == count find inTheCircleOfFriends_shorter(S1,_Sx1);
   	M == count find inTheCircleOfFriends_shorter(S2,_Sx2);
   	check ((N as Integer) > (M as Integer));
   }
   
   pattern theOnesWithTheBiggestCircle(S:Student) = {
   	neg find moreFriendsThan(Sx,S);
   }
   
   
   /*
    * Step 7: combine everything, @PatternUI, @ObservableValue
    * 
    * We want to find those years, which had courses taught by the busiest teacher
    * and included the most sociable students
    * 
    */
    @PatternUI(message="The busiest teacher $T.name$ taught the most sociable student $S.name$ in $Y.startingDate")
    @ObservableValue(name = "Y", expression="Y.startingDate")
    @ObservableValue(name = "C", expression="C.subject")
    @ObservableValue(name = "T", expression="T.name")
    @ObservableValue(name = "S", expression="S.name")
    pattern finalPattern(Y:Year,C:Course,T:Teacher,S:Student) = {
    	Year.schoolClasses.courses(Y,C);
    	Course.teacher(C,T);
    	Student.schoolClass.courses(S,C);
    	
    	find theOnesWithTheBiggestCircle(S);
    	find teachesTheMostCourses(T);
    }